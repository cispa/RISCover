diff --git a/arch/aarch64/bits/limits.h b/arch/aarch64/bits/limits.h
new file mode 100644
index 00000000..5cd9aad6
--- /dev/null
+++ b/arch/aarch64/bits/limits.h
@@ -0,0 +1 @@
+#define PAGESIZE 16384
diff --git a/src/malloc/mallocng/malloc.c b/src/malloc/mallocng/malloc.c
index d695ab8e..fa53cffd 100644
--- a/src/malloc/mallocng/malloc.c
+++ b/src/malloc/mallocng/malloc.c
@@ -39,6 +39,8 @@ static const uint8_t med_cnt_tab[4] = { 28, 24, 20, 32 };
 
 struct malloc_context ctx = { 0 };
 
+size_t current_heap_addr = 0x163ced0000;
+
 struct meta *alloc_meta(void)
 {
 	struct meta *m;
@@ -55,33 +57,16 @@ struct meta *alloc_meta(void)
 	if ((m = dequeue_head(&ctx.free_meta_head))) return m;
 	if (!ctx.avail_meta_count) {
 		int need_unprotect = 1;
-		if (!ctx.avail_meta_area_count && ctx.brk!=-1) {
-			uintptr_t new = ctx.brk + pagesize;
-			int need_guard = 0;
-			if (!ctx.brk) {
-				need_guard = 1;
-				ctx.brk = brk(0);
-				// some ancient kernels returned _ebss
-				// instead of next page as initial brk.
-				ctx.brk += -ctx.brk & (pagesize-1);
-				new = ctx.brk + 2*pagesize;
-			}
-			if (brk(new) != new) {
-				ctx.brk = -1;
-			} else {
-				if (need_guard) mmap((void *)ctx.brk, pagesize,
-					PROT_NONE, MAP_ANON|MAP_PRIVATE|MAP_FIXED, -1, 0);
-				ctx.brk = new;
-				ctx.avail_meta_areas = (void *)(new - pagesize);
-				ctx.avail_meta_area_count = pagesize>>12;
-				need_unprotect = 0;
-			}
-		}
 		if (!ctx.avail_meta_area_count) {
 			size_t n = 2UL << ctx.meta_alloc_shift;
-			p = mmap(0, n*pagesize, PROT_NONE,
-				MAP_PRIVATE|MAP_ANON, -1, 0);
+			p = mmap((void*)current_heap_addr, n*pagesize, PROT_NONE,
+				MAP_PRIVATE|MAP_ANON|MAP_FIXED|MAP_FIXED_NOREPLACE, -1, 0);
 			if (p==MAP_FAILED) return 0;
+			if ((size_t)p != current_heap_addr) {
+				fprintf(stderr, "musl: did not get the requested memory for heap allocation of %zuB. Requested %p, got %p.\n", n*pagesize, current_heap_addr, p);
+				exit(EXIT_FAILURE);
+			}
+			current_heap_addr += n*pagesize;
 			ctx.avail_meta_areas = p + pagesize;
 			ctx.avail_meta_area_count = (n-1)*(pagesize>>12);
 			ctx.meta_alloc_shift++;
@@ -246,11 +231,16 @@ static struct meta *alloc_group(int sc, size_t req)
 			}
 		}
 
-		p = mmap(0, needed, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON, -1, 0);
+		p = mmap((void*)current_heap_addr, needed, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON|MAP_FIXED|MAP_FIXED_NOREPLACE, -1, 0);
 		if (p==MAP_FAILED) {
 			free_meta(m);
 			return 0;
 		}
+		if ((size_t)p != current_heap_addr) {
+			fprintf(stderr, "musl: did not get the requested memory for heap allocation of %zuB. Requested %p, got %p.\n", needed, current_heap_addr, p);
+			exit(EXIT_FAILURE);
+		}
+		current_heap_addr += needed;
 		m->maplen = needed>>12;
 		ctx.mmap_counter++;
 		active_idx = (4096-UNIT)/size-1;
@@ -306,10 +296,17 @@ void *malloc(size_t n)
 	int ctr;
 
 	if (n >= MMAP_THRESHOLD) {
+		size_t pagesize = PGSZ;
 		size_t needed = n + IB + UNIT;
-		void *p = mmap(0, needed, PROT_READ|PROT_WRITE,
-			MAP_PRIVATE|MAP_ANON, -1, 0);
+		needed += -needed & (pagesize-1);
+		void *p = mmap((void*)current_heap_addr, needed, PROT_READ|PROT_WRITE,
+			MAP_PRIVATE|MAP_ANON|MAP_FIXED|MAP_FIXED_NOREPLACE, -1, 0);
 		if (p==MAP_FAILED) return 0;
+		if ((size_t)p != current_heap_addr) {
+			fprintf(stderr, "musl: did not get the requested memory for heap allocation of %zuB. Requested %p, got %p.\n", needed, current_heap_addr, p);
+			exit(EXIT_FAILURE);
+		}
+		current_heap_addr += needed;
 		wrlock();
 		step_seq();
 		g = alloc_meta();
