#!/usr/bin/env python3

# TODO NOTE: The header is not static and cant be generated offline because we filter instructions through it.

import pyutils.config as config

if __name__ == '__main__':
    import sys, os
    sys.path.append(os.getenv("FRAMEWORK_ROOT"))

import os

def write_header(collection, name="instructions.h"):
    # First, collect unique mnemonics.
    mnemonics = []
    for instr in collection.instructions.values():
        mnem = instr['mnemonic']
        if mnem not in mnemonics:
            mnemonics.append(mnem)

    # Collect unique non-null field names.
    field_names = set()
    for instr in collection.instructions.values():
        for fld in instr['fields']:
            if fld['name'] is not None:
                field_names.add(fld['name'])
    field_names = sorted(field_names)

    header_filename = os.path.join(os.getenv("FRAMEWORK_ROOT"), f"client/src/lib/{config.ARCH}/{name}")
    MAX_FIELDS = 17

    with open(header_filename, "w") as f:
        f.write("/* This file is auto generated by genheader.py */\n\n")
        f.write("#pragma once\n")
        f.write("#include <stdint.h>\n")
        f.write("#include <stdlib.h>\n\n")

        # Mnemonic enum.
        f.write("typedef enum {\n")
        for m in mnemonics:
            f.write("    MNEMONIC_%s,\n" % m.upper().replace(".", "_"))
        f.write("    MNEMONIC_COUNT\n")
        f.write("} Mnemonic;\n\n")

        # Mnemonic enum to string
        f.write("const char* mnemonic_to_str(Mnemonic mnemonic) {\n    switch (mnemonic) {\n")
        for m in mnemonics:
            enum_m = "MNEMONIC_%s" % m.upper().replace(".", "_")
            f.write('        case %s: return "%s";\n' % (enum_m, m))
        f.write('        default: exit(EXIT_FAILURE);\n')
        f.write('    }\n')
        f.write('}\n\n')

        # FieldType enum.
        f.write("typedef enum {\n")
        f.write("    FIELD_NAME_NONE = 0,\n")
        for nm in field_names:
            enum_nm = "FIELD_NAME_" + nm.replace(".", "_")
            f.write("    %s,\n" % enum_nm)
        f.write("    FIELD_NAME_COUNT\n")
        f.write("} FieldType;\n\n")

        f.write("#define MAX_FIELDS %d\n\n" % MAX_FIELDS)

        # FieldType enum to string
        f.write("const char* field_type_to_str(FieldType field) {\n    switch (field) {\n")
        for nm in field_names:
            enum_nm = "FIELD_NAME_" + nm.replace(".", "_")
            f.write('        case %s: return "%s";\n' % (enum_nm, nm))
        f.write('        case FIELD_NAME_NONE: return "";\n')
        f.write('        default: exit(EXIT_FAILURE);\n')
        f.write('    }\n')
        f.write('}\n\n')

        # Define a structure for each field.
        f.write("typedef struct {\n")
        f.write("    unsigned range_high;\n")
        f.write("    unsigned range_low;\n")
        f.write("    FieldType name;\n")
        f.write("    uint32_t value;\n")
        f.write("    uint32_t mask;\n")
        f.write("} InstrField;\n\n")

        # Define the instruction template structure.
        f.write("typedef struct {\n")
        f.write("    Mnemonic mnemonic;\n")
        f.write("    const char *description;\n")
        f.write("    InstrField fields[MAX_FIELDS];\n")
        f.write("    unsigned field_count;\n")
        f.write("    uint32_t mask;\n")
        f.write("    uint32_t value;\n")
        f.write("    const char *extension;\n")
        f.write("} Instruction;\n\n")

        # Write out the array of instructions.
        f.write("static const Instruction instructions[] = {\n")
        for instr in collection.instructions.values():
            # 'instr' is already the dictionary containing the instruction info.
            mnem_enum = "MNEMONIC_" + instr['mnemonic'].upper().replace(".", "_")
            desc = instr.get('description', "")
            ext = instr.get('extension')
            if type(ext) == list:
                ext = ",".join(ext)
            mask, value = instr.get('combined_mask')
            flds = instr['fields']
            f.write("    { %s, \"%s\", {\n" % (mnem_enum, desc))

            assert(len(flds) < MAX_FIELDS);

            # Write each field.
            for fld in flds:
                r_hi, r_lo = fld['range']
                if fld['name'] is None:
                    name_enum = "FIELD_NAME_NONE"
                else:
                    name_enum = "FIELD_NAME_" + fld['name'].replace(".", "_")
                f.write("        { %d, %d, %s, %u, %u },\n" % (r_hi, r_lo, name_enum, fld['value'], fld['mask']))

                # fld_mask = fld['mask']
                # fld_value = fld['value']
                # bits = r_hi-r_lo+1
                # print(fld)
                # print(bits)
                # print("mask   ", hex(fld_mask))
                # print("value  ", hex(fld_value))
                # print("bitmask", hex((1<<bits)-1))
                # print("mask   ", bin(fld_mask))
                # print("value  ", bin(fld_value))
                # print("bitmask", bin((1<<bits)-1))
                # assert(fld_mask == 0 or fld_mask == (1<<bits)-1)

            f.write("    }, %d, 0x%08X, 0x%08X, \"%s\" },\n" % (len(flds), mask, value, ext))
        f.write("};\n\n")

        # Also output the count of instructions.
        f.write("static const int instructions_count = sizeof(instructions)/sizeof(instructions[0]);\n\n")

    # print("Header file '%s' generated." % header_filename)

if __name__ == '__main__':
    import argparse
    from pyutils.shared_logic import parse_and_set_flags
    parse_and_set_flags()

    config.VECTOR = True
    config.FLOATS = True

    from pyutils.shared_logic import parser_add_common_extension_parsing, get_collection_from_args, get_common_argparser

    parser = get_common_argparser()
    parser_add_common_extension_parsing(parser)
    args = parser.parse_args()

    assert(args.all_extensions)

    collection = get_collection_from_args(args)

    write_header(collection)
